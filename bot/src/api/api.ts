/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * однойкрови.рф
 * API сервиса однойкрови.рф для донороcства крови и помощи животным
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/api/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface HandlersErrorResponse
 */
export interface HandlersErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof HandlersErrorResponse
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface HandlersReferenceItem
 */
export interface HandlersReferenceItem {
    /**
     * 
     * @type {string}
     * @memberof HandlersReferenceItem
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof HandlersReferenceItem
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface HandlersReferenceResponse
 */
export interface HandlersReferenceResponse {
    /**
     * 
     * @type {Array<HandlersReferenceItem>}
     * @memberof HandlersReferenceResponse
     */
    data?: Array<HandlersReferenceItem>;
}
/**
 * 
 * @export
 * @interface HandlersSimpleRegistrationRequest
 */
export interface HandlersSimpleRegistrationRequest {
    /**
     * 
     * @type {string}
     * @memberof HandlersSimpleRegistrationRequest
     */
    fullName?: string;
    /**
     * 
     * @type {number}
     * @memberof HandlersSimpleRegistrationRequest
     */
    telegramId: number;
}
/**
 * 
 * @export
 * @interface HandlersSuccessResponse
 */
export interface HandlersSuccessResponse {
    /**
     * 
     * @type {any}
     * @memberof HandlersSuccessResponse
     */
    data?: any;
    /**
     * 
     * @type {string}
     * @memberof HandlersSuccessResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface ModelsBloodStock
 */
export interface ModelsBloodStock {
    /**
     * 
     * @type {number}
     * @memberof ModelsBloodStock
     */
    bloodTypeId?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsBloodStock
     */
    clinicId?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsBloodStock
     */
    expirationDate?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsBloodStock
     */
    id?: number;
    /**
     * 
     * @type {ModelsPetType}
     * @memberof ModelsBloodStock
     */
    petType?: ModelsPetType;
    /**
     * 
     * @type {number}
     * @memberof ModelsBloodStock
     */
    priceRub?: number;
    /**
     * 
     * @type {ModelsBloodStockStatus}
     * @memberof ModelsBloodStock
     */
    status?: ModelsBloodStockStatus;
    /**
     * 
     * @type {number}
     * @memberof ModelsBloodStock
     */
    volumeMl?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ModelsBloodStockStatus {
    Active = <any> 'active',
    Reserved = <any> 'reserved',
    Used = <any> 'used',
    Expired = <any> 'expired'
}
/**
 * 
 * @export
 * @interface ModelsDonorRequirements
 */
export interface ModelsDonorRequirements {
    /**
     * 
     * @type {Array<string>}
     * @memberof ModelsDonorRequirements
     */
    bloodTypes?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModelsDonorRequirements
     */
    healthConditions?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ModelsDonorRequirements
     */
    maxAge?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDonorRequirements
     */
    minAge?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsDonorRequirements
     */
    minWeight?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModelsDonorRequirements
     */
    vaccinations?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ModelsGender {
    Male = <any> 'male',
    Female = <any> 'female'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ModelsLivingCondition {
    Apartment = <any> 'apartment',
    House = <any> 'house',
    Aviary = <any> 'aviary',
    Other = <any> 'other'
}
/**
 * 
 * @export
 * @interface ModelsPet
 */
export interface ModelsPet {
    /**
     * 
     * @type {number}
     * @memberof ModelsPet
     */
    ageMonths?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsPet
     */
    ageYears?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsPet
     */
    bloodGroup?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsPet
     */
    breed?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsPet
     */
    chipNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsPet
     */
    dewormingDate?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsPet
     */
    ectoparasiteDate?: string;
    /**
     * 
     * @type {ModelsGender}
     * @memberof ModelsPet
     */
    gender?: ModelsGender;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsPet
     */
    hasChip?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ModelsPet
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsPet
     */
    isGuideDog?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsPet
     */
    isTherapist?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsPet
     */
    knowsBloodGroup?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelsPet
     */
    lastTransfusionDate?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsPet
     */
    latitude?: number;
    /**
     * 
     * @type {ModelsLivingCondition}
     * @memberof ModelsPet
     */
    livingCondition?: ModelsLivingCondition;
    /**
     * 
     * @type {number}
     * @memberof ModelsPet
     */
    longitude?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsPet
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsPet
     */
    ownerId?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsPet
     */
    photoUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsPet
     */
    sterilized?: boolean;
    /**
     * 
     * @type {ModelsPetType}
     * @memberof ModelsPet
     */
    type?: ModelsPetType;
    /**
     * 
     * @type {string}
     * @memberof ModelsPet
     */
    vaccinationDate?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsPet
     */
    weightKg?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ModelsPetType {
    Dog = <any> 'dog',
    Cat = <any> 'cat'
}
/**
 * 
 * @export
 * @interface ModelsUser
 */
export interface ModelsUser {
    /**
     * 
     * @type {boolean}
     * @memberof ModelsUser
     */
    allowGeo?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsUser
     */
    consentPd?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelsUser
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsUser
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsUser
     */
    fullName?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsUser
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsUser
     */
    locationId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsUser
     */
    onBoarding?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelsUser
     */
    organizationName?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsUser
     */
    phone?: string;
    /**
     * 
     * @type {ModelsUserRole}
     * @memberof ModelsUser
     */
    role?: ModelsUserRole;
    /**
     * 
     * @type {number}
     * @memberof ModelsUser
     */
    telegramId?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ModelsUserRole {
    User = <any> 'user',
    Clinic = <any> 'clinic',
    Admin = <any> 'admin',
    Donor = <any> 'donor'
}
/**
 * 
 * @export
 * @interface ModelsVetClinic
 */
export interface ModelsVetClinic {
    /**
     * 
     * @type {number}
     * @memberof ModelsVetClinic
     */
    appointmentRequirementId?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsVetClinic
     */
    clinicId?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsVetClinic
     */
    contactPersonName?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsVetClinic
     */
    contactPersonPosition?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsVetClinic
     */
    donorBonusPrograms?: string;
    /**
     * 
     * @type {ModelsDonorRequirements}
     * @memberof ModelsVetClinic
     */
    donorRequirements?: ModelsDonorRequirements;
    /**
     * 
     * @type {number}
     * @memberof ModelsVetClinic
     */
    latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsVetClinic
     */
    locationId?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsVetClinic
     */
    longitude?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsVetClinic
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsVetClinic
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsVetClinic
     */
    transfusionConditions?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsVetClinic
     */
    website?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsVetClinic
     */
    workHours?: string;
}
/**
 * 
 * @export
 * @interface ServicesBloodStockCreate
 */
export interface ServicesBloodStockCreate {
    /**
     * 
     * @type {number}
     * @memberof ServicesBloodStockCreate
     */
    bloodTypeId: number;
    /**
     * 
     * @type {number}
     * @memberof ServicesBloodStockCreate
     */
    clinicId?: number;
    /**
     * формат: \"2024-12-31\"
     * @type {string}
     * @memberof ServicesBloodStockCreate
     */
    expirationDate?: string;
    /**
     * 
     * @type {ModelsPetType}
     * @memberof ServicesBloodStockCreate
     */
    petType: ModelsPetType;
    /**
     * 
     * @type {ModelsBloodStockStatus}
     * @memberof ServicesBloodStockCreate
     */
    status?: ModelsBloodStockStatus;
    /**
     * 
     * @type {number}
     * @memberof ServicesBloodStockCreate
     */
    volumeMl?: number;
}
/**
 * 
 * @export
 * @interface ServicesBloodStockUpdate
 */
export interface ServicesBloodStockUpdate {
    /**
     * 
     * @type {string}
     * @memberof ServicesBloodStockUpdate
     */
    expirationDate?: string;
    /**
     * 
     * @type {ModelsBloodStockStatus}
     * @memberof ServicesBloodStockUpdate
     */
    status?: ModelsBloodStockStatus;
    /**
     * 
     * @type {number}
     * @memberof ServicesBloodStockUpdate
     */
    volumeMl?: number;
}
/**
 * 
 * @export
 * @interface ServicesPetCreate
 */
export interface ServicesPetCreate {
    /**
     * 
     * @type {number}
     * @memberof ServicesPetCreate
     */
    ageMonths?: number;
    /**
     * 
     * @type {number}
     * @memberof ServicesPetCreate
     */
    ageYears?: number;
    /**
     * 
     * @type {string}
     * @memberof ServicesPetCreate
     */
    bloodGroup?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesPetCreate
     */
    breed?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesPetCreate
     */
    chipNumber?: string;
    /**
     * 
     * @type {ModelsGender}
     * @memberof ServicesPetCreate
     */
    gender?: ModelsGender;
    /**
     * 
     * @type {boolean}
     * @memberof ServicesPetCreate
     */
    hasChip?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServicesPetCreate
     */
    isGuideDog?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServicesPetCreate
     */
    isTherapist?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServicesPetCreate
     */
    knowsBloodGroup?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ServicesPetCreate
     */
    latitude?: number;
    /**
     * 
     * @type {ModelsLivingCondition}
     * @memberof ServicesPetCreate
     */
    livingCondition?: ModelsLivingCondition;
    /**
     * 
     * @type {number}
     * @memberof ServicesPetCreate
     */
    longitude?: number;
    /**
     * 
     * @type {string}
     * @memberof ServicesPetCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesPetCreate
     */
    photoUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServicesPetCreate
     */
    sterilized?: boolean;
    /**
     * 
     * @type {ModelsPetType}
     * @memberof ServicesPetCreate
     */
    type?: ModelsPetType;
    /**
     * 
     * @type {number}
     * @memberof ServicesPetCreate
     */
    weightKg?: number;
}
/**
 * 
 * @export
 * @interface ServicesPetUpdate
 */
export interface ServicesPetUpdate {
    /**
     * 
     * @type {number}
     * @memberof ServicesPetUpdate
     */
    ageMonths?: number;
    /**
     * 
     * @type {number}
     * @memberof ServicesPetUpdate
     */
    ageYears?: number;
    /**
     * 
     * @type {string}
     * @memberof ServicesPetUpdate
     */
    bloodGroup?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesPetUpdate
     */
    breed?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesPetUpdate
     */
    chipNumber?: string;
    /**
     * 
     * @type {ModelsGender}
     * @memberof ServicesPetUpdate
     */
    gender?: ModelsGender;
    /**
     * 
     * @type {boolean}
     * @memberof ServicesPetUpdate
     */
    hasChip?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServicesPetUpdate
     */
    isGuideDog?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServicesPetUpdate
     */
    isTherapist?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServicesPetUpdate
     */
    knowsBloodGroup?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ServicesPetUpdate
     */
    latitude?: number;
    /**
     * 
     * @type {ModelsLivingCondition}
     * @memberof ServicesPetUpdate
     */
    livingCondition?: ModelsLivingCondition;
    /**
     * 
     * @type {number}
     * @memberof ServicesPetUpdate
     */
    longitude?: number;
    /**
     * 
     * @type {string}
     * @memberof ServicesPetUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesPetUpdate
     */
    photoUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ServicesPetUpdate
     */
    sterilized?: boolean;
    /**
     * 
     * @type {ModelsPetType}
     * @memberof ServicesPetUpdate
     */
    type?: ModelsPetType;
    /**
     * 
     * @type {number}
     * @memberof ServicesPetUpdate
     */
    weightKg?: number;
}
/**
 * 
 * @export
 * @interface ServicesUserRegistration
 */
export interface ServicesUserRegistration {
    /**
     * 
     * @type {boolean}
     * @memberof ServicesUserRegistration
     */
    consentPd: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServicesUserRegistration
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesUserRegistration
     */
    fullName: string;
    /**
     * 
     * @type {number}
     * @memberof ServicesUserRegistration
     */
    locationId: number;
    /**
     * 
     * @type {string}
     * @memberof ServicesUserRegistration
     */
    phone: string;
    /**
     * 
     * @type {ModelsUserRole}
     * @memberof ServicesUserRegistration
     */
    role: ModelsUserRole;
}
/**
 * 
 * @export
 * @interface ServicesUserUpdate
 */
export interface ServicesUserUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof ServicesUserUpdate
     */
    allowGeo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServicesUserUpdate
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesUserUpdate
     */
    fullName?: string;
    /**
     * 
     * @type {number}
     * @memberof ServicesUserUpdate
     */
    locationId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServicesUserUpdate
     */
    onBoarding?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServicesUserUpdate
     */
    phone?: string;
}
/**
 * 
 * @export
 * @interface ServicesVetClinicProfile
 */
export interface ServicesVetClinicProfile {
    /**
     * 
     * @type {ModelsVetClinic}
     * @memberof ServicesVetClinicProfile
     */
    clinic?: ModelsVetClinic;
}
/**
 * 
 * @export
 * @interface ServicesVetClinicRegistration
 */
export interface ServicesVetClinicRegistration {
    /**
     * 
     * @type {number}
     * @memberof ServicesVetClinicRegistration
     */
    appointmentRequirementId: number;
    /**
     * 
     * @type {string}
     * @memberof ServicesVetClinicRegistration
     */
    contactPersonName?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesVetClinicRegistration
     */
    contactPersonPosition?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesVetClinicRegistration
     */
    donorBonusPrograms?: string;
    /**
     * 
     * @type {number}
     * @memberof ServicesVetClinicRegistration
     */
    latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof ServicesVetClinicRegistration
     */
    locationId: number;
    /**
     * 
     * @type {number}
     * @memberof ServicesVetClinicRegistration
     */
    longitude?: number;
    /**
     * 
     * @type {string}
     * @memberof ServicesVetClinicRegistration
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesVetClinicRegistration
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesVetClinicRegistration
     */
    transfusionConditions?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesVetClinicRegistration
     */
    website?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesVetClinicRegistration
     */
    workHours?: string;
}
/**
 * 
 * @export
 * @interface ServicesVetClinicUpdate
 */
export interface ServicesVetClinicUpdate {
    /**
     * 
     * @type {number}
     * @memberof ServicesVetClinicUpdate
     */
    appointmentRequirementId?: number;
    /**
     * 
     * @type {string}
     * @memberof ServicesVetClinicUpdate
     */
    contactPersonName?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesVetClinicUpdate
     */
    contactPersonPosition?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesVetClinicUpdate
     */
    donorBonusPrograms?: string;
    /**
     * 
     * @type {number}
     * @memberof ServicesVetClinicUpdate
     */
    locationId?: number;
    /**
     * 
     * @type {string}
     * @memberof ServicesVetClinicUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesVetClinicUpdate
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesVetClinicUpdate
     */
    transfusionConditions?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesVetClinicUpdate
     */
    website?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicesVetClinicUpdate
     */
    workHours?: string;
}
/**
 * BloodStocksApi - fetch parameter creator
 * @export
 */
export const BloodStocksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает все запасы крови для конкретного типа крови
         * @summary Получение запасов крови по типу крови
         * @param {number} bloodTypeId ID типа крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksBloodTypeBloodTypeIdGet(bloodTypeId: number, options: any = {}): FetchArgs {
            // verify required parameter 'bloodTypeId' is not null or undefined
            if (bloodTypeId === null || bloodTypeId === undefined) {
                throw new RequiredError('bloodTypeId','Required parameter bloodTypeId was null or undefined when calling bloodStocksBloodTypeBloodTypeIdGet.');
            }
            const localVarPath = `/blood-stocks/blood-type/{blood_type_id}`
                .replace(`{${"blood_type_id"}}`, encodeURIComponent(String(bloodTypeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает все запасы крови для конкретной клиники
         * @summary Получение запасов крови клиники
         * @param {number} clinicId ID клиники
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksClinicClinicIdGet(clinicId: number, options: any = {}): FetchArgs {
            // verify required parameter 'clinicId' is not null or undefined
            if (clinicId === null || clinicId === undefined) {
                throw new RequiredError('clinicId','Required parameter clinicId was null or undefined when calling bloodStocksClinicClinicIdGet.');
            }
            const localVarPath = `/blood-stocks/clinic/{clinic_id}`
                .replace(`{${"clinic_id"}}`, encodeURIComponent(String(clinicId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список всех запасов крови в системе
         * @summary Получение всех запасов крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksGet(options: any = {}): FetchArgs {
            const localVarPath = `/blood-stocks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет запас крови из системы
         * @summary Удаление запаса крови
         * @param {number} id ID запаса крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling bloodStocksIdDelete.');
            }
            const localVarPath = `/blood-stocks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о конкретном запасе крови
         * @summary Получение запаса крови по ID
         * @param {number} id ID запаса крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling bloodStocksIdGet.');
            }
            const localVarPath = `/blood-stocks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет информацию о запасе крови
         * @summary Обновление запаса крови
         * @param {ServicesBloodStockUpdate} body Данные для обновления
         * @param {number} id ID запаса крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksIdPut(body: ServicesBloodStockUpdate, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling bloodStocksIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling bloodStocksIdPut.');
            }
            const localVarPath = `/blood-stocks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ServicesBloodStockUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает новый запас крови в системе
         * @summary Создание нового запаса крови
         * @param {ServicesBloodStockCreate} body Данные запаса крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksPost(body: ServicesBloodStockCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling bloodStocksPost.');
            }
            const localVarPath = `/blood-stocks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ServicesBloodStockCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Выполняет поиск запасов крови по различным параметрам (клиника, тип животного, тип крови, статус, объем, цена)
         * @summary Поиск запасов крови с фильтрами
         * @param {number} [clinicId] ID клиники
         * @param {string} [petType] Тип животного (dog/cat)
         * @param {number} [bloodTypeId] ID типа крови
         * @param {string} [status] Статус (active/reserved/used/expired)
         * @param {number} [minVolume] Минимальный объем (мл)
         * @param {number} [maxVolume] Максимальный объем (мл)
         * @param {number} [minPrice] Минимальная цена (руб)
         * @param {number} [maxPrice] Максимальная цена (руб)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksSearchGet(clinicId?: number, petType?: string, bloodTypeId?: number, status?: string, minVolume?: number, maxVolume?: number, minPrice?: number, maxPrice?: number, options: any = {}): FetchArgs {
            const localVarPath = `/blood-stocks/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clinicId !== undefined) {
                localVarQueryParameter['clinic_id'] = clinicId;
            }

            if (petType !== undefined) {
                localVarQueryParameter['pet_type'] = petType;
            }

            if (bloodTypeId !== undefined) {
                localVarQueryParameter['blood_type_id'] = bloodTypeId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minVolume !== undefined) {
                localVarQueryParameter['min_volume'] = minVolume;
            }

            if (maxVolume !== undefined) {
                localVarQueryParameter['max_volume'] = maxVolume;
            }

            if (minPrice !== undefined) {
                localVarQueryParameter['min_price'] = minPrice;
            }

            if (maxPrice !== undefined) {
                localVarQueryParameter['max_price'] = maxPrice;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BloodStocksApi - functional programming interface
 * @export
 */
export const BloodStocksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Возвращает все запасы крови для конкретного типа крови
         * @summary Получение запасов крови по типу крови
         * @param {number} bloodTypeId ID типа крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksBloodTypeBloodTypeIdGet(bloodTypeId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ModelsBloodStock>> {
            const localVarFetchArgs = BloodStocksApiFetchParamCreator(configuration).bloodStocksBloodTypeBloodTypeIdGet(bloodTypeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает все запасы крови для конкретной клиники
         * @summary Получение запасов крови клиники
         * @param {number} clinicId ID клиники
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksClinicClinicIdGet(clinicId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ModelsBloodStock>> {
            const localVarFetchArgs = BloodStocksApiFetchParamCreator(configuration).bloodStocksClinicClinicIdGet(clinicId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает список всех запасов крови в системе
         * @summary Получение всех запасов крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ModelsBloodStock>> {
            const localVarFetchArgs = BloodStocksApiFetchParamCreator(configuration).bloodStocksGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Удаляет запас крови из системы
         * @summary Удаление запаса крови
         * @param {number} id ID запаса крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersSuccessResponse> {
            const localVarFetchArgs = BloodStocksApiFetchParamCreator(configuration).bloodStocksIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает информацию о конкретном запасе крови
         * @summary Получение запаса крови по ID
         * @param {number} id ID запаса крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelsBloodStock> {
            const localVarFetchArgs = BloodStocksApiFetchParamCreator(configuration).bloodStocksIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Обновляет информацию о запасе крови
         * @summary Обновление запаса крови
         * @param {ServicesBloodStockUpdate} body Данные для обновления
         * @param {number} id ID запаса крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksIdPut(body: ServicesBloodStockUpdate, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersSuccessResponse> {
            const localVarFetchArgs = BloodStocksApiFetchParamCreator(configuration).bloodStocksIdPut(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Создает новый запас крови в системе
         * @summary Создание нового запаса крови
         * @param {ServicesBloodStockCreate} body Данные запаса крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksPost(body: ServicesBloodStockCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelsBloodStock> {
            const localVarFetchArgs = BloodStocksApiFetchParamCreator(configuration).bloodStocksPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Выполняет поиск запасов крови по различным параметрам (клиника, тип животного, тип крови, статус, объем, цена)
         * @summary Поиск запасов крови с фильтрами
         * @param {number} [clinicId] ID клиники
         * @param {string} [petType] Тип животного (dog/cat)
         * @param {number} [bloodTypeId] ID типа крови
         * @param {string} [status] Статус (active/reserved/used/expired)
         * @param {number} [minVolume] Минимальный объем (мл)
         * @param {number} [maxVolume] Максимальный объем (мл)
         * @param {number} [minPrice] Минимальная цена (руб)
         * @param {number} [maxPrice] Максимальная цена (руб)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksSearchGet(clinicId?: number, petType?: string, bloodTypeId?: number, status?: string, minVolume?: number, maxVolume?: number, minPrice?: number, maxPrice?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ModelsBloodStock>> {
            const localVarFetchArgs = BloodStocksApiFetchParamCreator(configuration).bloodStocksSearchGet(clinicId, petType, bloodTypeId, status, minVolume, maxVolume, minPrice, maxPrice, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BloodStocksApi - factory interface
 * @export
 */
export const BloodStocksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Возвращает все запасы крови для конкретного типа крови
         * @summary Получение запасов крови по типу крови
         * @param {number} bloodTypeId ID типа крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksBloodTypeBloodTypeIdGet(bloodTypeId: number, options?: any) {
            return BloodStocksApiFp(configuration).bloodStocksBloodTypeBloodTypeIdGet(bloodTypeId, options)(fetch, basePath);
        },
        /**
         * Возвращает все запасы крови для конкретной клиники
         * @summary Получение запасов крови клиники
         * @param {number} clinicId ID клиники
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksClinicClinicIdGet(clinicId: number, options?: any) {
            return BloodStocksApiFp(configuration).bloodStocksClinicClinicIdGet(clinicId, options)(fetch, basePath);
        },
        /**
         * Возвращает список всех запасов крови в системе
         * @summary Получение всех запасов крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksGet(options?: any) {
            return BloodStocksApiFp(configuration).bloodStocksGet(options)(fetch, basePath);
        },
        /**
         * Удаляет запас крови из системы
         * @summary Удаление запаса крови
         * @param {number} id ID запаса крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksIdDelete(id: number, options?: any) {
            return BloodStocksApiFp(configuration).bloodStocksIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Возвращает информацию о конкретном запасе крови
         * @summary Получение запаса крови по ID
         * @param {number} id ID запаса крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksIdGet(id: number, options?: any) {
            return BloodStocksApiFp(configuration).bloodStocksIdGet(id, options)(fetch, basePath);
        },
        /**
         * Обновляет информацию о запасе крови
         * @summary Обновление запаса крови
         * @param {ServicesBloodStockUpdate} body Данные для обновления
         * @param {number} id ID запаса крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksIdPut(body: ServicesBloodStockUpdate, id: number, options?: any) {
            return BloodStocksApiFp(configuration).bloodStocksIdPut(body, id, options)(fetch, basePath);
        },
        /**
         * Создает новый запас крови в системе
         * @summary Создание нового запаса крови
         * @param {ServicesBloodStockCreate} body Данные запаса крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksPost(body: ServicesBloodStockCreate, options?: any) {
            return BloodStocksApiFp(configuration).bloodStocksPost(body, options)(fetch, basePath);
        },
        /**
         * Выполняет поиск запасов крови по различным параметрам (клиника, тип животного, тип крови, статус, объем, цена)
         * @summary Поиск запасов крови с фильтрами
         * @param {number} [clinicId] ID клиники
         * @param {string} [petType] Тип животного (dog/cat)
         * @param {number} [bloodTypeId] ID типа крови
         * @param {string} [status] Статус (active/reserved/used/expired)
         * @param {number} [minVolume] Минимальный объем (мл)
         * @param {number} [maxVolume] Максимальный объем (мл)
         * @param {number} [minPrice] Минимальная цена (руб)
         * @param {number} [maxPrice] Максимальная цена (руб)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bloodStocksSearchGet(clinicId?: number, petType?: string, bloodTypeId?: number, status?: string, minVolume?: number, maxVolume?: number, minPrice?: number, maxPrice?: number, options?: any) {
            return BloodStocksApiFp(configuration).bloodStocksSearchGet(clinicId, petType, bloodTypeId, status, minVolume, maxVolume, minPrice, maxPrice, options)(fetch, basePath);
        },
    };
};

/**
 * BloodStocksApi - object-oriented interface
 * @export
 * @class BloodStocksApi
 * @extends {BaseAPI}
 */
export class BloodStocksApi extends BaseAPI {
    /**
     * Возвращает все запасы крови для конкретного типа крови
     * @summary Получение запасов крови по типу крови
     * @param {number} bloodTypeId ID типа крови
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BloodStocksApi
     */
    public bloodStocksBloodTypeBloodTypeIdGet(bloodTypeId: number, options?: any) {
        return BloodStocksApiFp(this.configuration).bloodStocksBloodTypeBloodTypeIdGet(bloodTypeId, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает все запасы крови для конкретной клиники
     * @summary Получение запасов крови клиники
     * @param {number} clinicId ID клиники
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BloodStocksApi
     */
    public bloodStocksClinicClinicIdGet(clinicId: number, options?: any) {
        return BloodStocksApiFp(this.configuration).bloodStocksClinicClinicIdGet(clinicId, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает список всех запасов крови в системе
     * @summary Получение всех запасов крови
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BloodStocksApi
     */
    public bloodStocksGet(options?: any) {
        return BloodStocksApiFp(this.configuration).bloodStocksGet(options)(this.fetch, this.basePath);
    }

    /**
     * Удаляет запас крови из системы
     * @summary Удаление запаса крови
     * @param {number} id ID запаса крови
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BloodStocksApi
     */
    public bloodStocksIdDelete(id: number, options?: any) {
        return BloodStocksApiFp(this.configuration).bloodStocksIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает информацию о конкретном запасе крови
     * @summary Получение запаса крови по ID
     * @param {number} id ID запаса крови
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BloodStocksApi
     */
    public bloodStocksIdGet(id: number, options?: any) {
        return BloodStocksApiFp(this.configuration).bloodStocksIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Обновляет информацию о запасе крови
     * @summary Обновление запаса крови
     * @param {ServicesBloodStockUpdate} body Данные для обновления
     * @param {number} id ID запаса крови
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BloodStocksApi
     */
    public bloodStocksIdPut(body: ServicesBloodStockUpdate, id: number, options?: any) {
        return BloodStocksApiFp(this.configuration).bloodStocksIdPut(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * Создает новый запас крови в системе
     * @summary Создание нового запаса крови
     * @param {ServicesBloodStockCreate} body Данные запаса крови
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BloodStocksApi
     */
    public bloodStocksPost(body: ServicesBloodStockCreate, options?: any) {
        return BloodStocksApiFp(this.configuration).bloodStocksPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Выполняет поиск запасов крови по различным параметрам (клиника, тип животного, тип крови, статус, объем, цена)
     * @summary Поиск запасов крови с фильтрами
     * @param {number} [clinicId] ID клиники
     * @param {string} [petType] Тип животного (dog/cat)
     * @param {number} [bloodTypeId] ID типа крови
     * @param {string} [status] Статус (active/reserved/used/expired)
     * @param {number} [minVolume] Минимальный объем (мл)
     * @param {number} [maxVolume] Максимальный объем (мл)
     * @param {number} [minPrice] Минимальная цена (руб)
     * @param {number} [maxPrice] Максимальная цена (руб)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BloodStocksApi
     */
    public bloodStocksSearchGet(clinicId?: number, petType?: string, bloodTypeId?: number, status?: string, minVolume?: number, maxVolume?: number, minPrice?: number, maxPrice?: number, options?: any) {
        return BloodStocksApiFp(this.configuration).bloodStocksSearchGet(clinicId, petType, bloodTypeId, status, minVolume, maxVolume, minPrice, maxPrice, options)(this.fetch, this.basePath);
    }

}
/**
 * PetsApi - fetch parameter creator
 * @export
 */
export const PetsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Удаляет питомца из системы
         * @summary Удаление питомца по ID
         * @param {number} id ID питомца
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        petsIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling petsIdDelete.');
            }
            const localVarPath = `/pets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о питомце по его идентификатору
         * @summary Получение питомца по ID
         * @param {number} id ID питомца
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        petsIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling petsIdGet.');
            }
            const localVarPath = `/pets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет информацию о питомце
         * @summary Обновление данных питомца
         * @param {ServicesPetUpdate} body Данные для обновления
         * @param {number} id ID питомца
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        petsIdPut(body: ServicesPetUpdate, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling petsIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling petsIdPut.');
            }
            const localVarPath = `/pets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ServicesPetUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает всех питомцев конкретного пользователя
         * @summary Получение питомцев пользователя
         * @param {number} userId ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        petsUserUserIdGet(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling petsUserUserIdGet.');
            }
            const localVarPath = `/pets/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает нового питомца для пользователя
         * @summary Создание нового питомца
         * @param {ServicesPetCreate} body Данные питомца
         * @param {number} userId ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        petsUserUserIdPost(body: ServicesPetCreate, userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling petsUserUserIdPost.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling petsUserUserIdPost.');
            }
            const localVarPath = `/pets/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ServicesPetCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PetsApi - functional programming interface
 * @export
 */
export const PetsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Удаляет питомца из системы
         * @summary Удаление питомца по ID
         * @param {number} id ID питомца
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        petsIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersSuccessResponse> {
            const localVarFetchArgs = PetsApiFetchParamCreator(configuration).petsIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает информацию о питомце по его идентификатору
         * @summary Получение питомца по ID
         * @param {number} id ID питомца
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        petsIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelsPet> {
            const localVarFetchArgs = PetsApiFetchParamCreator(configuration).petsIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Обновляет информацию о питомце
         * @summary Обновление данных питомца
         * @param {ServicesPetUpdate} body Данные для обновления
         * @param {number} id ID питомца
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        petsIdPut(body: ServicesPetUpdate, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersSuccessResponse> {
            const localVarFetchArgs = PetsApiFetchParamCreator(configuration).petsIdPut(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает всех питомцев конкретного пользователя
         * @summary Получение питомцев пользователя
         * @param {number} userId ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        petsUserUserIdGet(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ModelsPet>> {
            const localVarFetchArgs = PetsApiFetchParamCreator(configuration).petsUserUserIdGet(userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Создает нового питомца для пользователя
         * @summary Создание нового питомца
         * @param {ServicesPetCreate} body Данные питомца
         * @param {number} userId ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        petsUserUserIdPost(body: ServicesPetCreate, userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelsPet> {
            const localVarFetchArgs = PetsApiFetchParamCreator(configuration).petsUserUserIdPost(body, userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PetsApi - factory interface
 * @export
 */
export const PetsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Удаляет питомца из системы
         * @summary Удаление питомца по ID
         * @param {number} id ID питомца
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        petsIdDelete(id: number, options?: any) {
            return PetsApiFp(configuration).petsIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Возвращает информацию о питомце по его идентификатору
         * @summary Получение питомца по ID
         * @param {number} id ID питомца
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        petsIdGet(id: number, options?: any) {
            return PetsApiFp(configuration).petsIdGet(id, options)(fetch, basePath);
        },
        /**
         * Обновляет информацию о питомце
         * @summary Обновление данных питомца
         * @param {ServicesPetUpdate} body Данные для обновления
         * @param {number} id ID питомца
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        petsIdPut(body: ServicesPetUpdate, id: number, options?: any) {
            return PetsApiFp(configuration).petsIdPut(body, id, options)(fetch, basePath);
        },
        /**
         * Возвращает всех питомцев конкретного пользователя
         * @summary Получение питомцев пользователя
         * @param {number} userId ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        petsUserUserIdGet(userId: number, options?: any) {
            return PetsApiFp(configuration).petsUserUserIdGet(userId, options)(fetch, basePath);
        },
        /**
         * Создает нового питомца для пользователя
         * @summary Создание нового питомца
         * @param {ServicesPetCreate} body Данные питомца
         * @param {number} userId ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        petsUserUserIdPost(body: ServicesPetCreate, userId: number, options?: any) {
            return PetsApiFp(configuration).petsUserUserIdPost(body, userId, options)(fetch, basePath);
        },
    };
};

/**
 * PetsApi - object-oriented interface
 * @export
 * @class PetsApi
 * @extends {BaseAPI}
 */
export class PetsApi extends BaseAPI {
    /**
     * Удаляет питомца из системы
     * @summary Удаление питомца по ID
     * @param {number} id ID питомца
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetsApi
     */
    public petsIdDelete(id: number, options?: any) {
        return PetsApiFp(this.configuration).petsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает информацию о питомце по его идентификатору
     * @summary Получение питомца по ID
     * @param {number} id ID питомца
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetsApi
     */
    public petsIdGet(id: number, options?: any) {
        return PetsApiFp(this.configuration).petsIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Обновляет информацию о питомце
     * @summary Обновление данных питомца
     * @param {ServicesPetUpdate} body Данные для обновления
     * @param {number} id ID питомца
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetsApi
     */
    public petsIdPut(body: ServicesPetUpdate, id: number, options?: any) {
        return PetsApiFp(this.configuration).petsIdPut(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает всех питомцев конкретного пользователя
     * @summary Получение питомцев пользователя
     * @param {number} userId ID пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetsApi
     */
    public petsUserUserIdGet(userId: number, options?: any) {
        return PetsApiFp(this.configuration).petsUserUserIdGet(userId, options)(this.fetch, this.basePath);
    }

    /**
     * Создает нового питомца для пользователя
     * @summary Создание нового питомца
     * @param {ServicesPetCreate} body Данные питомца
     * @param {number} userId ID пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetsApi
     */
    public petsUserUserIdPost(body: ServicesPetCreate, userId: number, options?: any) {
        return PetsApiFp(this.configuration).petsUserUserIdPost(body, userId, options)(this.fetch, this.basePath);
    }

}
/**
 * ReferenceApi - fetch parameter creator
 * @export
 */
export const ReferenceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает список групп крови животных для выбора на фронтенде
         * @summary Получение групп крови животных
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceBloodGroupsGet(options: any = {}): FetchArgs {
            const localVarPath = `/reference/blood-groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает все доступные статусы поиска крови для выбора на фронтенде
         * @summary Получение всех статусов поиска крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceBloodSearchStatusesGet(options: any = {}): FetchArgs {
            const localVarPath = `/reference/blood-search-statuses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает все доступные статусы запаса крови для выбора на фронтенде
         * @summary Получение всех статусов запаса крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceBloodStockStatusesGet(options: any = {}): FetchArgs {
            const localVarPath = `/reference/blood-stock-statuses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список пород животных для указанного типа животного для выбора на фронтенде
         * @summary Получение пород животных по типу
         * @param {string} petType Тип животного (dog, cat, etc.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceBreedsByTypeGet(petType: string, options: any = {}): FetchArgs {
            // verify required parameter 'petType' is not null or undefined
            if (petType === null || petType === undefined) {
                throw new RequiredError('petType','Required parameter petType was null or undefined when calling referenceBreedsByTypeGet.');
            }
            const localVarPath = `/reference/breeds-by-type`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (petType !== undefined) {
                localVarQueryParameter['petType'] = petType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список всех пород животных в базе для выбора на фронтенде
         * @summary Получение всех пород животных
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceBreedsGet(options: any = {}): FetchArgs {
            const localVarPath = `/reference/breeds`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает все доступные статусы донорства для выбора на фронтенде
         * @summary Получение всех статусов донорства
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceDonationStatusesGet(options: any = {}): FetchArgs {
            const localVarPath = `/reference/donation-statuses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает все доступные значения пола для выбора на фронтенде
         * @summary Получение всех значений пола
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceGendersGet(options: any = {}): FetchArgs {
            const localVarPath = `/reference/genders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает все доступные условия проживания для выбора на фронтенде
         * @summary Получение всех условий проживания
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceLivingConditionsGet(options: any = {}): FetchArgs {
            const localVarPath = `/reference/living-conditions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает все доступные типы животных для выбора на фронтенде
         * @summary Получение всех типов животных
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referencePetTypesGet(options: any = {}): FetchArgs {
            const localVarPath = `/reference/pet-types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает все доступные роли пользователей для выбора на фронтенде
         * @summary Получение всех ролей пользователей
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceUserRolesGet(options: any = {}): FetchArgs {
            const localVarPath = `/reference/user-roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferenceApi - functional programming interface
 * @export
 */
export const ReferenceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Возвращает список групп крови животных для выбора на фронтенде
         * @summary Получение групп крови животных
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceBloodGroupsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersReferenceResponse> {
            const localVarFetchArgs = ReferenceApiFetchParamCreator(configuration).referenceBloodGroupsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает все доступные статусы поиска крови для выбора на фронтенде
         * @summary Получение всех статусов поиска крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceBloodSearchStatusesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersReferenceResponse> {
            const localVarFetchArgs = ReferenceApiFetchParamCreator(configuration).referenceBloodSearchStatusesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает все доступные статусы запаса крови для выбора на фронтенде
         * @summary Получение всех статусов запаса крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceBloodStockStatusesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersReferenceResponse> {
            const localVarFetchArgs = ReferenceApiFetchParamCreator(configuration).referenceBloodStockStatusesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает список пород животных для указанного типа животного для выбора на фронтенде
         * @summary Получение пород животных по типу
         * @param {string} petType Тип животного (dog, cat, etc.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceBreedsByTypeGet(petType: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersReferenceResponse> {
            const localVarFetchArgs = ReferenceApiFetchParamCreator(configuration).referenceBreedsByTypeGet(petType, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает список всех пород животных в базе для выбора на фронтенде
         * @summary Получение всех пород животных
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceBreedsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersReferenceResponse> {
            const localVarFetchArgs = ReferenceApiFetchParamCreator(configuration).referenceBreedsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает все доступные статусы донорства для выбора на фронтенде
         * @summary Получение всех статусов донорства
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceDonationStatusesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersReferenceResponse> {
            const localVarFetchArgs = ReferenceApiFetchParamCreator(configuration).referenceDonationStatusesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает все доступные значения пола для выбора на фронтенде
         * @summary Получение всех значений пола
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceGendersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersReferenceResponse> {
            const localVarFetchArgs = ReferenceApiFetchParamCreator(configuration).referenceGendersGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает все доступные условия проживания для выбора на фронтенде
         * @summary Получение всех условий проживания
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceLivingConditionsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersReferenceResponse> {
            const localVarFetchArgs = ReferenceApiFetchParamCreator(configuration).referenceLivingConditionsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает все доступные типы животных для выбора на фронтенде
         * @summary Получение всех типов животных
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referencePetTypesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersReferenceResponse> {
            const localVarFetchArgs = ReferenceApiFetchParamCreator(configuration).referencePetTypesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает все доступные роли пользователей для выбора на фронтенде
         * @summary Получение всех ролей пользователей
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceUserRolesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersReferenceResponse> {
            const localVarFetchArgs = ReferenceApiFetchParamCreator(configuration).referenceUserRolesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ReferenceApi - factory interface
 * @export
 */
export const ReferenceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Возвращает список групп крови животных для выбора на фронтенде
         * @summary Получение групп крови животных
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceBloodGroupsGet(options?: any) {
            return ReferenceApiFp(configuration).referenceBloodGroupsGet(options)(fetch, basePath);
        },
        /**
         * Возвращает все доступные статусы поиска крови для выбора на фронтенде
         * @summary Получение всех статусов поиска крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceBloodSearchStatusesGet(options?: any) {
            return ReferenceApiFp(configuration).referenceBloodSearchStatusesGet(options)(fetch, basePath);
        },
        /**
         * Возвращает все доступные статусы запаса крови для выбора на фронтенде
         * @summary Получение всех статусов запаса крови
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceBloodStockStatusesGet(options?: any) {
            return ReferenceApiFp(configuration).referenceBloodStockStatusesGet(options)(fetch, basePath);
        },
        /**
         * Возвращает список пород животных для указанного типа животного для выбора на фронтенде
         * @summary Получение пород животных по типу
         * @param {string} petType Тип животного (dog, cat, etc.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceBreedsByTypeGet(petType: string, options?: any) {
            return ReferenceApiFp(configuration).referenceBreedsByTypeGet(petType, options)(fetch, basePath);
        },
        /**
         * Возвращает список всех пород животных в базе для выбора на фронтенде
         * @summary Получение всех пород животных
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceBreedsGet(options?: any) {
            return ReferenceApiFp(configuration).referenceBreedsGet(options)(fetch, basePath);
        },
        /**
         * Возвращает все доступные статусы донорства для выбора на фронтенде
         * @summary Получение всех статусов донорства
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceDonationStatusesGet(options?: any) {
            return ReferenceApiFp(configuration).referenceDonationStatusesGet(options)(fetch, basePath);
        },
        /**
         * Возвращает все доступные значения пола для выбора на фронтенде
         * @summary Получение всех значений пола
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceGendersGet(options?: any) {
            return ReferenceApiFp(configuration).referenceGendersGet(options)(fetch, basePath);
        },
        /**
         * Возвращает все доступные условия проживания для выбора на фронтенде
         * @summary Получение всех условий проживания
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceLivingConditionsGet(options?: any) {
            return ReferenceApiFp(configuration).referenceLivingConditionsGet(options)(fetch, basePath);
        },
        /**
         * Возвращает все доступные типы животных для выбора на фронтенде
         * @summary Получение всех типов животных
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referencePetTypesGet(options?: any) {
            return ReferenceApiFp(configuration).referencePetTypesGet(options)(fetch, basePath);
        },
        /**
         * Возвращает все доступные роли пользователей для выбора на фронтенде
         * @summary Получение всех ролей пользователей
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referenceUserRolesGet(options?: any) {
            return ReferenceApiFp(configuration).referenceUserRolesGet(options)(fetch, basePath);
        },
    };
};

/**
 * ReferenceApi - object-oriented interface
 * @export
 * @class ReferenceApi
 * @extends {BaseAPI}
 */
export class ReferenceApi extends BaseAPI {
    /**
     * Возвращает список групп крови животных для выбора на фронтенде
     * @summary Получение групп крови животных
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceApi
     */
    public referenceBloodGroupsGet(options?: any) {
        return ReferenceApiFp(this.configuration).referenceBloodGroupsGet(options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает все доступные статусы поиска крови для выбора на фронтенде
     * @summary Получение всех статусов поиска крови
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceApi
     */
    public referenceBloodSearchStatusesGet(options?: any) {
        return ReferenceApiFp(this.configuration).referenceBloodSearchStatusesGet(options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает все доступные статусы запаса крови для выбора на фронтенде
     * @summary Получение всех статусов запаса крови
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceApi
     */
    public referenceBloodStockStatusesGet(options?: any) {
        return ReferenceApiFp(this.configuration).referenceBloodStockStatusesGet(options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает список пород животных для указанного типа животного для выбора на фронтенде
     * @summary Получение пород животных по типу
     * @param {string} petType Тип животного (dog, cat, etc.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceApi
     */
    public referenceBreedsByTypeGet(petType: string, options?: any) {
        return ReferenceApiFp(this.configuration).referenceBreedsByTypeGet(petType, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает список всех пород животных в базе для выбора на фронтенде
     * @summary Получение всех пород животных
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceApi
     */
    public referenceBreedsGet(options?: any) {
        return ReferenceApiFp(this.configuration).referenceBreedsGet(options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает все доступные статусы донорства для выбора на фронтенде
     * @summary Получение всех статусов донорства
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceApi
     */
    public referenceDonationStatusesGet(options?: any) {
        return ReferenceApiFp(this.configuration).referenceDonationStatusesGet(options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает все доступные значения пола для выбора на фронтенде
     * @summary Получение всех значений пола
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceApi
     */
    public referenceGendersGet(options?: any) {
        return ReferenceApiFp(this.configuration).referenceGendersGet(options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает все доступные условия проживания для выбора на фронтенде
     * @summary Получение всех условий проживания
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceApi
     */
    public referenceLivingConditionsGet(options?: any) {
        return ReferenceApiFp(this.configuration).referenceLivingConditionsGet(options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает все доступные типы животных для выбора на фронтенде
     * @summary Получение всех типов животных
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceApi
     */
    public referencePetTypesGet(options?: any) {
        return ReferenceApiFp(this.configuration).referencePetTypesGet(options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает все доступные роли пользователей для выбора на фронтенде
     * @summary Получение всех ролей пользователей
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceApi
     */
    public referenceUserRolesGet(options?: any) {
        return ReferenceApiFp(this.configuration).referenceUserRolesGet(options)(this.fetch, this.basePath);
    }

}
/**
 * RootApi - fetch parameter creator
 * @export
 */
export const RootApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает информационное сообщение о сервере
         * @summary Корневой эндпоинт
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options: any = {}): FetchArgs {
            const localVarPath = `/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RootApi - functional programming interface
 * @export
 */
export const RootApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Возвращает информационное сообщение о сервере
         * @summary Корневой эндпоинт
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = RootApiFetchParamCreator(configuration).rootGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RootApi - factory interface
 * @export
 */
export const RootApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Возвращает информационное сообщение о сервере
         * @summary Корневой эндпоинт
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: any) {
            return RootApiFp(configuration).rootGet(options)(fetch, basePath);
        },
    };
};

/**
 * RootApi - object-oriented interface
 * @export
 * @class RootApi
 * @extends {BaseAPI}
 */
export class RootApi extends BaseAPI {
    /**
     * Возвращает информационное сообщение о сервере
     * @summary Корневой эндпоинт
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    public rootGet(options?: any) {
        return RootApiFp(this.configuration).rootGet(options)(this.fetch, this.basePath);
    }

}
/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Удаляет пользователя из системы (soft delete)
         * @summary Удаление пользователя по ID
         * @param {number} id ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userIdDelete.');
            }
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о пользователе по его идентификатору
         * @summary Получение пользователя по ID
         * @param {number} id ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userIdGet.');
            }
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет информацию о пользователе
         * @summary Обновление данных пользователя
         * @param {ServicesUserUpdate} body Данные для обновления
         * @param {number} id ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIdPut(body: ServicesUserUpdate, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling userIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userIdPut.');
            }
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ServicesUserUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Регистрирует нового пользователя в системе
         * @summary Регистрация нового пользователя
         * @param {ServicesUserRegistration} body Данные для регистрации пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegisterPost(body: ServicesUserRegistration, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling userRegisterPost.');
            }
            const localVarPath = `/user/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ServicesUserRegistration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает пользователя с Telegram ID и именем (для команды Start)
         * @summary Простая регистрация пользователя
         * @param {HandlersSimpleRegistrationRequest} body Данные для простой регистрации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegisterSimplePost(body: HandlersSimpleRegistrationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling userRegisterSimplePost.');
            }
            const localVarPath = `/user/register/simple`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HandlersSimpleRegistrationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о пользователе по его Telegram ID
         * @summary Получение пользователя по Telegram ID
         * @param {number} telegramId Telegram ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTelegramGet(telegramId: number, options: any = {}): FetchArgs {
            // verify required parameter 'telegramId' is not null or undefined
            if (telegramId === null || telegramId === undefined) {
                throw new RequiredError('telegramId','Required parameter telegramId was null or undefined when calling userTelegramGet.');
            }
            const localVarPath = `/user/telegram`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (telegramId !== undefined) {
                localVarQueryParameter['telegram_id'] = telegramId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Удаляет пользователя из системы (soft delete)
         * @summary Удаление пользователя по ID
         * @param {number} id ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersSuccessResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает информацию о пользователе по его идентификатору
         * @summary Получение пользователя по ID
         * @param {number} id ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelsUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Обновляет информацию о пользователе
         * @summary Обновление данных пользователя
         * @param {ServicesUserUpdate} body Данные для обновления
         * @param {number} id ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIdPut(body: ServicesUserUpdate, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersSuccessResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userIdPut(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Регистрирует нового пользователя в системе
         * @summary Регистрация нового пользователя
         * @param {ServicesUserRegistration} body Данные для регистрации пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegisterPost(body: ServicesUserRegistration, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelsUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userRegisterPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Создает пользователя с Telegram ID и именем (для команды Start)
         * @summary Простая регистрация пользователя
         * @param {HandlersSimpleRegistrationRequest} body Данные для простой регистрации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegisterSimplePost(body: HandlersSimpleRegistrationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelsUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userRegisterSimplePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает информацию о пользователе по его Telegram ID
         * @summary Получение пользователя по Telegram ID
         * @param {number} telegramId Telegram ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTelegramGet(telegramId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelsUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userTelegramGet(telegramId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Удаляет пользователя из системы (soft delete)
         * @summary Удаление пользователя по ID
         * @param {number} id ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIdDelete(id: number, options?: any) {
            return UsersApiFp(configuration).userIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Возвращает информацию о пользователе по его идентификатору
         * @summary Получение пользователя по ID
         * @param {number} id ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIdGet(id: number, options?: any) {
            return UsersApiFp(configuration).userIdGet(id, options)(fetch, basePath);
        },
        /**
         * Обновляет информацию о пользователе
         * @summary Обновление данных пользователя
         * @param {ServicesUserUpdate} body Данные для обновления
         * @param {number} id ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIdPut(body: ServicesUserUpdate, id: number, options?: any) {
            return UsersApiFp(configuration).userIdPut(body, id, options)(fetch, basePath);
        },
        /**
         * Регистрирует нового пользователя в системе
         * @summary Регистрация нового пользователя
         * @param {ServicesUserRegistration} body Данные для регистрации пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegisterPost(body: ServicesUserRegistration, options?: any) {
            return UsersApiFp(configuration).userRegisterPost(body, options)(fetch, basePath);
        },
        /**
         * Создает пользователя с Telegram ID и именем (для команды Start)
         * @summary Простая регистрация пользователя
         * @param {HandlersSimpleRegistrationRequest} body Данные для простой регистрации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegisterSimplePost(body: HandlersSimpleRegistrationRequest, options?: any) {
            return UsersApiFp(configuration).userRegisterSimplePost(body, options)(fetch, basePath);
        },
        /**
         * Возвращает информацию о пользователе по его Telegram ID
         * @summary Получение пользователя по Telegram ID
         * @param {number} telegramId Telegram ID пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTelegramGet(telegramId: number, options?: any) {
            return UsersApiFp(configuration).userTelegramGet(telegramId, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Удаляет пользователя из системы (soft delete)
     * @summary Удаление пользователя по ID
     * @param {number} id ID пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userIdDelete(id: number, options?: any) {
        return UsersApiFp(this.configuration).userIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает информацию о пользователе по его идентификатору
     * @summary Получение пользователя по ID
     * @param {number} id ID пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userIdGet(id: number, options?: any) {
        return UsersApiFp(this.configuration).userIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Обновляет информацию о пользователе
     * @summary Обновление данных пользователя
     * @param {ServicesUserUpdate} body Данные для обновления
     * @param {number} id ID пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userIdPut(body: ServicesUserUpdate, id: number, options?: any) {
        return UsersApiFp(this.configuration).userIdPut(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * Регистрирует нового пользователя в системе
     * @summary Регистрация нового пользователя
     * @param {ServicesUserRegistration} body Данные для регистрации пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userRegisterPost(body: ServicesUserRegistration, options?: any) {
        return UsersApiFp(this.configuration).userRegisterPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Создает пользователя с Telegram ID и именем (для команды Start)
     * @summary Простая регистрация пользователя
     * @param {HandlersSimpleRegistrationRequest} body Данные для простой регистрации
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userRegisterSimplePost(body: HandlersSimpleRegistrationRequest, options?: any) {
        return UsersApiFp(this.configuration).userRegisterSimplePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает информацию о пользователе по его Telegram ID
     * @summary Получение пользователя по Telegram ID
     * @param {number} telegramId Telegram ID пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userTelegramGet(telegramId: number, options?: any) {
        return UsersApiFp(this.configuration).userTelegramGet(telegramId, options)(this.fetch, this.basePath);
    }

}
/**
 * VetClinicsApi - fetch parameter creator
 * @export
 */
export const VetClinicsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Удаляет клинику из системы (soft delete)
         * @summary Удаление клиники по ID
         * @param {number} id ID клиники
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vetClinicsIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling vetClinicsIdDelete.');
            }
            const localVarPath = `/vet-clinics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает полный профиль ветеринарной клиники
         * @summary Получение профиля клиники по ID
         * @param {number} id ID клиники
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vetClinicsIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling vetClinicsIdGet.');
            }
            const localVarPath = `/vet-clinics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет информацию о ветеринарной клинике
         * @summary Обновление профиля клиники
         * @param {ServicesVetClinicUpdate} body Данные для обновления
         * @param {number} id ID клиники
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vetClinicsIdPut(body: ServicesVetClinicUpdate, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling vetClinicsIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling vetClinicsIdPut.');
            }
            const localVarPath = `/vet-clinics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ServicesVetClinicUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список всех ветеринарных клиник в указанной локации
         * @summary Получение всех клиник по ID локации
         * @param {number} locationId ID локации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vetClinicsLocationLocationIdGet(locationId: number, options: any = {}): FetchArgs {
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling vetClinicsLocationLocationIdGet.');
            }
            const localVarPath = `/vet-clinics/location/{location_id}`
                .replace(`{${"location_id"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Регистрирует новую ветеринарную клинику в системе
         * @summary Регистрация новой ветеринарной клиники
         * @param {ServicesVetClinicRegistration} body Данные клиники
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vetClinicsRegisterPost(body: ServicesVetClinicRegistration, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling vetClinicsRegisterPost.');
            }
            const localVarPath = `/vet-clinics/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ServicesVetClinicRegistration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VetClinicsApi - functional programming interface
 * @export
 */
export const VetClinicsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Удаляет клинику из системы (soft delete)
         * @summary Удаление клиники по ID
         * @param {number} id ID клиники
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vetClinicsIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersSuccessResponse> {
            const localVarFetchArgs = VetClinicsApiFetchParamCreator(configuration).vetClinicsIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает полный профиль ветеринарной клиники
         * @summary Получение профиля клиники по ID
         * @param {number} id ID клиники
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vetClinicsIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ServicesVetClinicProfile> {
            const localVarFetchArgs = VetClinicsApiFetchParamCreator(configuration).vetClinicsIdGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Обновляет информацию о ветеринарной клинике
         * @summary Обновление профиля клиники
         * @param {ServicesVetClinicUpdate} body Данные для обновления
         * @param {number} id ID клиники
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vetClinicsIdPut(body: ServicesVetClinicUpdate, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HandlersSuccessResponse> {
            const localVarFetchArgs = VetClinicsApiFetchParamCreator(configuration).vetClinicsIdPut(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает список всех ветеринарных клиник в указанной локации
         * @summary Получение всех клиник по ID локации
         * @param {number} locationId ID локации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vetClinicsLocationLocationIdGet(locationId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ModelsVetClinic>> {
            const localVarFetchArgs = VetClinicsApiFetchParamCreator(configuration).vetClinicsLocationLocationIdGet(locationId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Регистрирует новую ветеринарную клинику в системе
         * @summary Регистрация новой ветеринарной клиники
         * @param {ServicesVetClinicRegistration} body Данные клиники
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vetClinicsRegisterPost(body: ServicesVetClinicRegistration, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelsVetClinic> {
            const localVarFetchArgs = VetClinicsApiFetchParamCreator(configuration).vetClinicsRegisterPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VetClinicsApi - factory interface
 * @export
 */
export const VetClinicsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Удаляет клинику из системы (soft delete)
         * @summary Удаление клиники по ID
         * @param {number} id ID клиники
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vetClinicsIdDelete(id: number, options?: any) {
            return VetClinicsApiFp(configuration).vetClinicsIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Возвращает полный профиль ветеринарной клиники
         * @summary Получение профиля клиники по ID
         * @param {number} id ID клиники
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vetClinicsIdGet(id: number, options?: any) {
            return VetClinicsApiFp(configuration).vetClinicsIdGet(id, options)(fetch, basePath);
        },
        /**
         * Обновляет информацию о ветеринарной клинике
         * @summary Обновление профиля клиники
         * @param {ServicesVetClinicUpdate} body Данные для обновления
         * @param {number} id ID клиники
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vetClinicsIdPut(body: ServicesVetClinicUpdate, id: number, options?: any) {
            return VetClinicsApiFp(configuration).vetClinicsIdPut(body, id, options)(fetch, basePath);
        },
        /**
         * Возвращает список всех ветеринарных клиник в указанной локации
         * @summary Получение всех клиник по ID локации
         * @param {number} locationId ID локации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vetClinicsLocationLocationIdGet(locationId: number, options?: any) {
            return VetClinicsApiFp(configuration).vetClinicsLocationLocationIdGet(locationId, options)(fetch, basePath);
        },
        /**
         * Регистрирует новую ветеринарную клинику в системе
         * @summary Регистрация новой ветеринарной клиники
         * @param {ServicesVetClinicRegistration} body Данные клиники
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vetClinicsRegisterPost(body: ServicesVetClinicRegistration, options?: any) {
            return VetClinicsApiFp(configuration).vetClinicsRegisterPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * VetClinicsApi - object-oriented interface
 * @export
 * @class VetClinicsApi
 * @extends {BaseAPI}
 */
export class VetClinicsApi extends BaseAPI {
    /**
     * Удаляет клинику из системы (soft delete)
     * @summary Удаление клиники по ID
     * @param {number} id ID клиники
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VetClinicsApi
     */
    public vetClinicsIdDelete(id: number, options?: any) {
        return VetClinicsApiFp(this.configuration).vetClinicsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает полный профиль ветеринарной клиники
     * @summary Получение профиля клиники по ID
     * @param {number} id ID клиники
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VetClinicsApi
     */
    public vetClinicsIdGet(id: number, options?: any) {
        return VetClinicsApiFp(this.configuration).vetClinicsIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Обновляет информацию о ветеринарной клинике
     * @summary Обновление профиля клиники
     * @param {ServicesVetClinicUpdate} body Данные для обновления
     * @param {number} id ID клиники
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VetClinicsApi
     */
    public vetClinicsIdPut(body: ServicesVetClinicUpdate, id: number, options?: any) {
        return VetClinicsApiFp(this.configuration).vetClinicsIdPut(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает список всех ветеринарных клиник в указанной локации
     * @summary Получение всех клиник по ID локации
     * @param {number} locationId ID локации
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VetClinicsApi
     */
    public vetClinicsLocationLocationIdGet(locationId: number, options?: any) {
        return VetClinicsApiFp(this.configuration).vetClinicsLocationLocationIdGet(locationId, options)(this.fetch, this.basePath);
    }

    /**
     * Регистрирует новую ветеринарную клинику в системе
     * @summary Регистрация новой ветеринарной клиники
     * @param {ServicesVetClinicRegistration} body Данные клиники
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VetClinicsApi
     */
    public vetClinicsRegisterPost(body: ServicesVetClinicRegistration, options?: any) {
        return VetClinicsApiFp(this.configuration).vetClinicsRegisterPost(body, options)(this.fetch, this.basePath);
    }

}
